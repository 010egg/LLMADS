<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>DeepSeek èŠå¤©åº”ç”¨</title>
  <!-- å¼•å…¥TailwindCSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background: url("https://img-musesai.163264.com/pic/202501/xutPRQnS8JOY.jpg")
                  no-repeat center center fixed;
      background-size: cover;
      font-family: 'Microsoft YaHei', Arial, sans-serif;
    }
    .page-overlay {
      background-color: rgba(255,255,255,0.85);
      backdrop-filter: blur(4px);
    }
    .content-area pre code {
      background-color: #2d2d2d;
      color: #f8f8f2;
      padding: 0.5rem;
      border-radius: 0.25rem;
      display: block;
      white-space: pre-wrap;
      margin: 0.5em 0;
      overflow-x: auto;
    }
    .typing-cursor::after {
      content: '|';
      margin-left: 4px;
      animation: blink 1s infinite;
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
  </style>
</head>
{% raw %}
<body class="min-h-screen flex">
  <!-- å·¦ä¾§ï¼šä¼šè¯åˆ—è¡¨ -->
  <div class="w-1/4 bg-white bg-opacity-80 p-4 overflow-y-auto" style="max-height: 100vh;">
    <button @click="createConversation"
            class="w-full bg-indigo-600 text-white py-2 px-4 rounded mb-3">
      + æ–°ä¼šè¯
    </button>
    <ul class="space-y-1">
      <li v-for="conv in conversations" :key="conv.id" class="flex items-center justify-between p-2 rounded cursor-pointer"
          :class="conv.id === currentConvId ? 'bg-indigo-100 font-semibold' : 'hover:bg-gray-100'"
          @click="switchConversation(conv.id)">
        <span v-if="!conv.editing" @dblclick.stop="conv.editing = true">{{ conv.name }}</span>
        <input v-else type="text" v-model="conv.name" @blur="renameConversation(conv)" @keyup.enter="renameConversation(conv)" class="border px-1"/>
        <button @click.stop="deleteConversation(conv.id)" class="text-red-500 text-sm ml-2">åˆ é™¤</button>
      </li>
    </ul>
  </div>

  <!-- å³ä¾§ï¼šèŠå¤©åŒºåŸŸ -->
  <div id="app" class="flex-1 page-overlay max-w-full mx-4 p-6">
    <div class="flex items-center justify-between mb-4">
      <div class="flex items-center space-x-3">
        <img src="https://images.unsplash.com/photo-1614583225154-5fcdda07019e?fm=jpg&q=60&w=200"
             alt="Avatar"
             class="w-14 h-14 object-cover rounded-full shadow-lg border-2 border-indigo-300">
        <div>
          <h1 class="text-2xl font-bold text-indigo-700">æ™ºè„‘</h1>
          <p class="text-xs text-gray-500 font-light">æ–°ç”Ÿã€åˆ›æ„ã€æ¢ç´¢</p>
        </div>
      </div>
      <div class="text-sm text-gray-700">
        çŠ¶æ€:
        <span :class="statusClass" class="text-xl">â—</span>
      </div>
    </div>

    <!-- èŠå¤©è®°å½•æ˜¾ç¤ºåŒºåŸŸ -->
    <div class="content-area min-h-[300px] p-3 bg-gray-50 rounded-lg mb-4 overflow-y-auto" style="max-height: 60vh;">
      <div v-if="error" class="text-red-600 font-semibold">
        âŒ é”™è¯¯: {{ error }}
      </div>
      <div v-for="(msg, index) in messages" :key="index" class="mb-2">
        <div v-if="msg.role === 'user'" class="text-right text-gray-800">
          <strong>ä½ ï¼š</strong>{{ msg.content }}
        </div>
        <!-- è°ƒç”¨ parseMarkdown æ–¹æ³•æ¥è§£æ Markdown -->
        <div v-else class="text-indigo-700" v-html="msg.html ? msg.html : parseMarkdown(msg.content)"></div>
      </div>
    </div>

    <!-- å…¬ç”¨è¾“å…¥åŒºåŸŸï¼ˆæ—¢ä½œä¸ºèŠå¤©å†…å®¹ä¹Ÿä½œä¸º PDF æ–‡ä»¶å¤¹è·¯å¾„è¾“å…¥ï¼‰ -->
    <div class="mb-4">
      <label class="block text-sm font-medium mb-2">è¯·è¾“å…¥å†…å®¹ï¼ˆèŠå¤©æˆ–PDFæ–‡ä»¶å¤¹è·¯å¾„ï¼‰</label>
      <textarea v-model="userInput"
                @keydown.enter="onEnter"
                class="w-full px-3 py-2 rounded border focus:outline-none focus:ring-2 focus:ring-indigo-400 resize-none"
                placeholder="è¯·è¾“å…¥èŠå¤©å†…å®¹æˆ–PDFæ–‡ä»¶å¤¹è·¯å¾„"
                rows="3"></textarea>
    </div>

    <!-- æŒ‰é’®ç»„ï¼ˆå‘é€ã€è¯­éŸ³ã€è§£æï¼‰ -->
    <div class="flex items-center space-x-2 mb-4">
      <button @click="sendRequest"
              class="bg-gradient-to-r from-pink-500 to-indigo-500 hover:from-pink-600 hover:to-indigo-600 text-white px-4 py-2 rounded shadow transform transition duration-300 hover:scale-105">
        {{ isLoading ? 'è¯·æ±‚ä¸­...' : 'å‘é€è¯·æ±‚' }}
      </button>
      <button @click="toggleRecording"
              class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-2 rounded shadow transform transition duration-300 hover:scale-105">
        {{ isRecording ? 'åœæ­¢å½•éŸ³' : 'ğŸ¤ è¯­éŸ³è¾“å…¥' }}
      </button>
      <button @click="processPdfs"
              class="bg-blue-500 text-white px-4 py-2 rounded shadow transform transition duration-300 hover:scale-105">
        è§£æPDF
      </button>
    </div>

    <!-- PDFè§£æç»“æœå±•ç¤ºï¼ˆå¦‚æœæœ‰è¿”å›ï¼‰ -->
    <div v-if="pdfResult" class="mt-4 p-4 bg-white rounded shadow">
      <h3 class="text-lg font-bold mb-2">PDF è§£æç»“æœ</h3>
      <pre class="bg-gray-200 p-2 rounded">{{ pdfResult }}</pre>
    </div>

    <!-- ä½¿ç”¨æŒ‡å— -->
    <details class="text-sm cursor-pointer border-t pt-2 mt-4">
      <summary class="text-indigo-600 underline mb-2">ä½¿ç”¨æŒ‡å—ï¼ˆç‚¹å‡»å±•å¼€ï¼‰</summary>
      <div class="mt-2 space-y-2">
        <p>1. åœ¨ä¸Šæ–¹è¾“å…¥æ¡†è¾“å…¥èŠå¤©å†…å®¹ï¼Œæˆ–è¾“å…¥PDFæ–‡ä»¶å¤¹è·¯å¾„ã€‚</p>
        <p>2. ç‚¹å‡»â€œå‘é€è¯·æ±‚â€æäº¤èŠå¤©å†…å®¹ï¼›ç‚¹å‡»â€œè§£æPDFâ€å°†è¾“å…¥å†…å®¹ä½œä¸ºæ–‡ä»¶å¤¹è·¯å¾„è§£æPDFæ–‡ä»¶ã€‚</p>
        <p>3. èŠå¤©å›å¤æ”¯æŒ Markdown æ ¼å¼ï¼ˆæ ‡é¢˜ã€åŠ ç²—ã€ä»£ç å—ç­‰ï¼‰ã€‚</p>
        <p>4. è¯­éŸ³è¾“å…¥æŒ‰é’®ç”¨äºè¯­éŸ³è¯†åˆ«ï¼Œå°†è½¬æ¢ç»“æœå¡«å…¥è¾“å…¥æ¡†ã€‚</p>
        <p>5. å¦‚é‡é”™è¯¯ï¼Œè¯·æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°åŠåç«¯æ—¥å¿—ã€‚</p>
      </div>
    </details>
  </div>

  <!-- åŠ è½½ Vue.js ä¸ Marked.js -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    const { createApp } = Vue;
    createApp({
      data() {
        return {
          userInput: '',
          error: '',
          isLoading: false,
          isRecording: false,
          status: 'idle',
          conversations: [],
          currentConvId: null,
          messages: [],
          pdfResult: ''
        };
      },
      computed: {
        statusClass() {
          return {
            'text-green-500': this.status === 'success',
            'text-red-500': this.status === 'error',
            'text-yellow-500 animate-ping': this.status === 'loading',
            'text-gray-400': this.status === 'idle'
          };
        }
      },
      created() {
        this.fetchConversations();
        this.initResizeObserver();
      },
      methods: {
        parseMarkdown(text) {
          return globalThis.marked ? globalThis.marked.parse(text) : text;
        },
        scrollToBottom() {
          this.$nextTick(() => {
            const chatArea = document.querySelector('.content-area');
            if (chatArea) {
              chatArea.scrollTop = chatArea.scrollHeight;
            }
          });
        },
        initResizeObserver() {
          if (typeof ResizeObserver !== 'undefined') {
            const observer = new ResizeObserver(entries => {
              console.log("èŠå¤©åŒºåŸŸå°ºå¯¸å˜åŒ–ï¼š", entries);
            });
            const chatArea = document.querySelector('.content-area');
            if (chatArea) {
              observer.observe(chatArea);
            }
          } else {
            console.warn("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ ResizeObserver");
          }
        },
        async fetchConversations() {
          try {
            const resp = await fetch('/api/conversations');
            const data = await resp.json();
            this.conversations = data;
            if (this.conversations.length > 0) {
              this.currentConvId = this.conversations[0].id;
              this.switchConversation(this.currentConvId);
            }
          } catch (e) {
            console.error("è·å–ä¼šè¯å¤±è´¥", e);
            this.error = "è·å–ä¼šè¯å¤±è´¥";
          }
        },
        async createConversation() {
          try {
            const resp = await fetch('/api/conversations', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({})
            });
            const newConv = await resp.json();
            this.conversations.unshift(newConv);
            this.currentConvId = newConv.id;
            this.messages = [];
          } catch (e) {
            console.error("åˆ›å»ºä¼šè¯å¤±è´¥", e);
            this.error = "åˆ›å»ºä¼šè¯å¤±è´¥";
          }
        },
        async switchConversation(convId) {
          this.error = '';
          try {
            const resp = await fetch(`/api/conversations/${convId}`);
            const convData = await resp.json();
            this.messages = convData.messages || [];
            this.messages = this.messages.map(msg => {
              try {
                msg.html = globalThis.marked ? globalThis.marked.parse(msg.content) : msg.content;
              } catch (e) {
                console.error('Markdownè§£æå¤±è´¥:', e);
                msg.html = msg.content;
              }
              return msg;
            });
            this.$nextTick(() => {
              const chatArea = document.querySelector('.content-area');
              chatArea.scrollTop = chatArea.scrollHeight;
            });
          } catch (e) {
            console.error("åŠ è½½ä¼šè¯å¤±è´¥", e);
            this.error = "åŠ è½½ä¼šè¯å¤±è´¥";
          }
        },
        async renameConversation(conv) {
          conv.editing = false;
          const newName = conv.name.trim() || "æœªå‘½å";
          conv.name = newName;
          try {
            await fetch(`/api/conversations/${conv.id}`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name: newName })
            });
          } catch (e) {
            console.error("é‡å‘½åå¤±è´¥", e);
          }
        },
        async deleteConversation(convId) {
          if (!confirm("ç¡®å®šåˆ é™¤è¯¥ä¼šè¯å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚")) return;
          try {
            await fetch(`/api/conversations/${convId}`, { method: 'DELETE' });
            this.conversations = this.conversations.filter(c => c.id !== convId);
            if (this.currentConvId === convId) {
              this.messages = [];
              this.currentConvId = this.conversations.length ? this.conversations[0].id : null;
              if (this.currentConvId) this.switchConversation(this.currentConvId);
            }
          } catch (e) {
            console.error("åˆ é™¤å¤±è´¥", e);
            alert("åˆ é™¤å¤±è´¥");
          }
        },
        onEnter(e) {
          if (e.shiftKey) return;
          e.preventDefault();
          this.sendRequest();
        },
        async sendRequest() {
          if (!this.userInput.trim()) {
            this.error = 'è¯·è¾“å…¥å†…å®¹æˆ–ä½¿ç”¨è¯­éŸ³è¾“å…¥ã€‚';
            return;
          }
          const userText = this.userInput.trim();
          this.userInput = '';
          this.isLoading = true;
          this.error = '';
          this.status = 'loading';

          // å°†ç”¨æˆ·æ¶ˆæ¯æ·»åŠ åˆ°å½“å‰æ¶ˆæ¯åˆ—è¡¨ä¸­
          this.messages.push({ role: 'user', content: userText });
          try {
            const resp = await fetch('/api/chat', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                user_input: userText,
                conversation_id: this.currentConvId
              })
            });
            if (!resp.ok) {
              const errorText = await resp.text();
              throw new Error(`åç«¯é”™è¯¯: ${errorText}`);
            }
            const data = await resp.json();
            if (data.error) throw new Error(data.error);
            const assistantText = data.raw || '';
            const assistMsg = {
              role: 'assistant',
              content: assistantText,
              html: this.parseMarkdown(assistantText)
            };
            this.messages.push(assistMsg);
            this.status = 'success';
            this.scrollToBottom();
          } catch (e) {
            this.error = e.message;
            this.status = 'error';
            console.error(e);
          } finally {
            this.isLoading = false;
          }
        },
        toggleRecording() {
          if (!('SpeechRecognition' in window) && !('webkitSpeechRecognition' in window)) {
            this.error = 'æ­¤æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¾“å…¥ï¼Œè¯·æ›´æ¢Chromeå¹¶ä½¿ç”¨HTTPSã€‚';
            this.status = 'error';
            return;
          }
          if (this.isRecording) {
            this.recognition.stop();
            return;
          }
          const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
          this.recognition = new SpeechRecognition();
          this.recognition.lang = 'zh-CN';
          this.recognition.interimResults = false;
          this.recognition.onresult = (event) => {
            if (event.results.length > 0) {
              this.userInput = event.results[0][0].transcript;
            }
          };
          this.recognition.onerror = (event) => {
            console.error('è¯­éŸ³è¯†åˆ«é”™è¯¯:', event);
            this.error = 'è¯­éŸ³è¯†åˆ«å‡ºé”™ï¼Œè¯·é‡è¯•ã€‚';
            this.status = 'error';
          };
          this.recognition.onend = () => {
            this.isRecording = false;
          };
          this.isRecording = true;
          this.recognition.start();
        },
        async processPdfs() {
          // æ­¤å¤„å°†å½“å‰è¾“å…¥æ¡†å†…å®¹ä½œä¸º PDF æ–‡ä»¶å¤¹è·¯å¾„
          if (!this.userInput.trim()) {
            alert("è¯·è¾“å…¥ PDF æ–‡ä»¶å¤¹è·¯å¾„");
            return;
          }
          const payload = {
            pdf_path: this.userInput.trim(),
            conversation_id: this.currentConvId ? this.currentConvId.toString() : null
          };
          try {
            const resp = await fetch("/api/process_pdfs", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });
            const data = await resp.json();
            if (data.error) {
              this.pdfResult = "é”™è¯¯ï¼š" + data.error;
            } else {
              this.pdfResult = JSON.stringify(data, null, 2);
              if (data.conversation_id) {
                this.currentConvId = data.conversation_id;
                this.switchConversation(this.currentConvId);
              }
            }
          } catch (err) {
            console.error(err);
            this.pdfResult = "è¯·æ±‚å¤±è´¥ï¼š" + err;
          }
        }
      }
    }).mount('body');
  </script>
</body>
{% endraw %}
</html>